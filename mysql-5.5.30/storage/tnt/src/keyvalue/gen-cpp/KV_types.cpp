/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifdef NTSE_KEYVALUE_SERVER
#include "KV_types.h"

namespace keyvalue {

int _kModeValues[] = {
  Mode::SET,
  Mode::INCR,
  Mode::DECR,
  Mode::APPEND,
  Mode::PREPEND,
  Mode::SETNULL
};
const char* _kModeNames[] = {
  "SET",
  "INCR",
  "DECR",
  "APPEND",
  "PREPEND",
  "SETNULL"
};
//const std::map<int, const char*> _Mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kModeValues, _kModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataTypeValues[] = {
  DataType::KV_TINYINT,
  DataType::KV_SMALLINT,
  DataType::KV_MEDIUMINT,
  DataType::KV_INT,
  DataType::KV_BIGINT,
  DataType::KV_FLOAT,
  DataType::KV_DOUBLE,
  DataType::KV_DECIMAL,
  DataType::KV_RID,
  DataType::KV_CHAR,
  DataType::KV_VARCHAR,
  DataType::KV_BINARY,
  DataType::KV_VARBINARY,
  DataType::KV_BLOB,
  DataType::KV_COL,
  DataType::KV_NULL
};
const char* _kDataTypeNames[] = {
  "KV_TINYINT",
  "KV_SMALLINT",
  "KV_MEDIUMINT",
  "KV_INT",
  "KV_BIGINT",
  "KV_FLOAT",
  "KV_DOUBLE",
  "KV_DECIMAL",
  "KV_RID",
  "KV_CHAR",
  "KV_VARCHAR",
  "KV_BINARY",
  "KV_VARBINARY",
  "KV_BLOB",
  "KV_COL",
  "KV_NULL"
};
//const std::map<int, const char*> _DataType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(16, _kDataTypeValues, _kDataTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOpValues[] = {
  Op::EQ,
  Op::GRATER,
  Op::LESS,
  Op::EQGRATER,
  Op::EQLESS,
  Op::NOTEQ,
  Op::LIKE,
  Op::NULLSAFEEQ,
  Op::ISNULL
};
const char* _kOpNames[] = {
  "EQ",
  "GRATER",
  "LESS",
  "EQGRATER",
  "EQLESS",
  "NOTEQ",
  "LIKE",
  "NULLSAFEEQ",
  "ISNULL"
};
//const std::map<int, const char*> _Op_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kOpValues, _kOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kErrCodeValues[] = {
  ErrCode::KV_EC_GENERIC,
  ErrCode::KV_EC_OUT_OF_MEM,
  ErrCode::KV_EC_FILE_NOT_EXIST,
  ErrCode::KV_EC_FILE_PERM_ERROR,
  ErrCode::KV_EC_DISK_FULL,
  ErrCode::KV_EC_FILE_EXIST,
  ErrCode::KV_EC_FILE_IN_USE,
  ErrCode::KV_EC_FILE_EOF,
  ErrCode::KV_EC_READ_FAIL,
  ErrCode::KV_EC_WRITE_FAIL,
  ErrCode::KV_EC_FILE_FAIL,
  ErrCode::KV_EC_ACCESS_OUT_OF_PAGE,
  ErrCode::KV_EC_PAGE_DAMAGE,
  ErrCode::KV_EC_CTRLFILE_DAMAGE,
  ErrCode::KV_EC_OVERFLOW,
  ErrCode::KV_EC_INDEX_BROKEN,
  ErrCode::KV_EC_INDEX_UNQIUE_VIOLATION,
  ErrCode::KV_EC_NOT_LOCKED,
  ErrCode::KV_EC_TOO_MANY_ROWLOCK,
  ErrCode::KV_EC_TOO_MANY_SESSION,
  ErrCode::KV_EC_NOT_SUPPORT,
  ErrCode::KV_EC_EXCEED_LIMIT,
  ErrCode::KV_EC_CORRUPTED_LOGFILE,
  ErrCode::KV_EC_MISSING_LOGFILE,
  ErrCode::KV_EC_DUP_TABLEID,
  ErrCode::KV_EC_INVALID_BACKUP,
  ErrCode::KV_EC_LOCK_TIMEOUT,
  ErrCode::KV_EC_LOCK_FAIL,
  ErrCode::KV_EC_SYNTAX_ERROR,
  ErrCode::KV_EC_ROW_TOO_LONG,
  ErrCode::KV_EC_NONEINDEX,
  ErrCode::KV_EC_DUPINDEX,
  ErrCode::KV_EC_COLDEF_ERROR,
  ErrCode::KV_EC_CANCELED,
  ErrCode::KV_EC_CORRUPTED,
  ErrCode::KV_EC_TABLEDEF_ERROR,
  ErrCode::KV_EC_INVALID_COL_GRP,
  ErrCode::KV_EC_NO_DICTIONARY,
  ErrCode::KV_EC_UNSUPPORTED_ENCODE,
  ErrCode::KV_EC_CONNCETION_REFUSED,
  ErrCode::KV_EC_TBLDEF_NOT_MATCH,
  ErrCode::KV_EC_TBLDEF_ACCESS_FAIL,
  ErrCode::KV_EC_TABLE_NOT_EXIST,
  ErrCode::KV_EC_KEY_ERROR,
  ErrCode::KV_EC_KET_NOT_MATCH,
  ErrCode::KV_EC_COL_NOT_EXIST,
  ErrCode::KV_EC_UNSUPPORTED_OP,
  ErrCode::KV_EC_COLTYPE_NOT_MATCH,
  ErrCode::KV_EC_TOO_FEW_COL,
  ErrCode::KV_EC_TOO_MANY_COL,
  ErrCode::KV_EC_KEY_EXIST,
  ErrCode::KV_EC_KEY_NOT_EXIST,
  ErrCode::KV_EC_UNKNOWN_HOST,
  ErrCode::KV_EC_TIMEOUT,
  ErrCode::KV_EC_UNSUPPORTED_DATATYPE,
  ErrCode::KV_EC_ILLEGAL_PARAMETER,
  ErrCode::KV_EC_COL_NOT_NULLABLE,
  ErrCode::KV_EC_THRIFT_ERROR,
  ErrCode::KV_EC_DUP_COL,
  ErrCode::KV_EC_CONFLICT_COLVALUE,
  ErrCode::KV_EC_VALUE_OVERFLOW,
  ErrCode::KV_EC_GENERAL_ERROR,
  ErrCode::KV_EC_TABLE_IN_DROPPING
};
const char* _kErrCodeNames[] = {
  "KV_EC_GENERIC",
  "KV_EC_OUT_OF_MEM",
  "KV_EC_FILE_NOT_EXIST",
  "KV_EC_FILE_PERM_ERROR",
  "KV_EC_DISK_FULL",
  "KV_EC_FILE_EXIST",
  "KV_EC_FILE_IN_USE",
  "KV_EC_FILE_EOF",
  "KV_EC_READ_FAIL",
  "KV_EC_WRITE_FAIL",
  "KV_EC_FILE_FAIL",
  "KV_EC_ACCESS_OUT_OF_PAGE",
  "KV_EC_PAGE_DAMAGE",
  "KV_EC_CTRLFILE_DAMAGE",
  "KV_EC_OVERFLOW",
  "KV_EC_INDEX_BROKEN",
  "KV_EC_INDEX_UNQIUE_VIOLATION",
  "KV_EC_NOT_LOCKED",
  "KV_EC_TOO_MANY_ROWLOCK",
  "KV_EC_TOO_MANY_SESSION",
  "KV_EC_NOT_SUPPORT",
  "KV_EC_EXCEED_LIMIT",
  "KV_EC_CORRUPTED_LOGFILE",
  "KV_EC_MISSING_LOGFILE",
  "KV_EC_DUP_TABLEID",
  "KV_EC_INVALID_BACKUP",
  "KV_EC_LOCK_TIMEOUT",
  "KV_EC_LOCK_FAIL",
  "KV_EC_SYNTAX_ERROR",
  "KV_EC_ROW_TOO_LONG",
  "KV_EC_NONEINDEX",
  "KV_EC_DUPINDEX",
  "KV_EC_COLDEF_ERROR",
  "KV_EC_CANCELED",
  "KV_EC_CORRUPTED",
  "KV_EC_TABLEDEF_ERROR",
  "KV_EC_INVALID_COL_GRP",
  "KV_EC_NO_DICTIONARY",
  "KV_EC_UNSUPPORTED_ENCODE",
  "KV_EC_CONNCETION_REFUSED",
  "KV_EC_TBLDEF_NOT_MATCH",
  "KV_EC_TBLDEF_ACCESS_FAIL",
  "KV_EC_TABLE_NOT_EXIST",
  "KV_EC_KEY_ERROR",
  "KV_EC_KET_NOT_MATCH",
  "KV_EC_COL_NOT_EXIST",
  "KV_EC_UNSUPPORTED_OP",
  "KV_EC_COLTYPE_NOT_MATCH",
  "KV_EC_TOO_FEW_COL",
  "KV_EC_TOO_MANY_COL",
  "KV_EC_KEY_EXIST",
  "KV_EC_KEY_NOT_EXIST",
  "KV_EC_UNKNOWN_HOST",
  "KV_EC_TIMEOUT",
  "KV_EC_UNSUPPORTED_DATATYPE",
  "KV_EC_ILLEGAL_PARAMETER",
  "KV_EC_COL_NOT_NULLABLE",
  "KV_EC_THRIFT_ERROR",
  "KV_EC_DUP_COL",
  "KV_EC_CONFLICT_COLVALUE",
  "KV_EC_VALUE_OVERFLOW",
  "KV_EC_GENERAL_ERROR",
  "KV_EC_TABLE_IN_DROPPING"
};
//const std::map<int, const char*> _ErrCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(63, _kErrCodeValues, _kErrCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TableInfo::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TableInfo::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TableInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_schemaName);
          this->__isset.m_schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_name);
          this->__isset.m_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableInfo");
  xfer += oprot->writeFieldBegin("m_schemaName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->m_schemaName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->m_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Attr::ascii_fingerprint = "15896F1A4438B1ECBB80CEA66AD0C4C5";
const uint8_t Attr::binary_fingerprint[16] = {0x15,0x89,0x6F,0x1A,0x44,0x38,0xB1,0xEC,0xBB,0x80,0xCE,0xA6,0x6A,0xD0,0xC4,0xC5};

uint32_t Attr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attrNo);
          this->__isset.attrNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Attr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Attr");
  xfer += oprot->writeFieldBegin("attrNo", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->attrNo);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Attrs::ascii_fingerprint = "1FDF0B80BFFC3EDB1C1482FBA9F948D8";
const uint8_t Attrs::binary_fingerprint[16] = {0x1F,0xDF,0x0B,0x80,0xBF,0xFC,0x3E,0xDB,0x1C,0x14,0x82,0xFB,0xA9,0xF9,0x48,0xD8};

uint32_t Attrs::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bmp);
          this->__isset.bmp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attrlist.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->attrlist.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->attrlist[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.attrlist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Attrs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Attrs");
  if (this->__isset.bmp) {
    xfer += oprot->writeFieldBegin("bmp", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->bmp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("attrlist", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->attrlist.size());
    std::vector<Attr> ::const_iterator _iter5;
    for (_iter5 = this->attrlist.begin(); _iter5 != this->attrlist.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* DriverUpdateMode::ascii_fingerprint = "17F32CB52D8039FF08647CFC2DEE080A";
const uint8_t DriverUpdateMode::binary_fingerprint[16] = {0x17,0xF3,0x2C,0xB5,0x2D,0x80,0x39,0xFF,0x08,0x64,0x7C,0xFC,0x2D,0xEE,0x08,0x0A};

uint32_t DriverUpdateMode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->mod = (Mode::type)ecast6;
          this->__isset.mod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attrNo);
          this->__isset.attrNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DriverUpdateMode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DriverUpdateMode");
  xfer += oprot->writeFieldBegin("mod", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->mod);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("attrNo", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->attrNo);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* DriverValue::ascii_fingerprint = "19B5240589E680301A7E32DF3971EFBE";
const uint8_t DriverValue::binary_fingerprint[16] = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

uint32_t DriverValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->dataType = (DataType::type)ecast7;
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DriverValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DriverValue");
  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->dataType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->dataValue);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* Cond::ascii_fingerprint = "E3DFA66152C1FAE5AA27A23CA63C713A";
const uint8_t Cond::binary_fingerprint[16] = {0xE3,0xDF,0xA6,0x61,0x52,0xC1,0xFA,0xE5,0xAA,0x27,0xA2,0x3C,0xA6,0x3C,0x71,0x3A};

uint32_t Cond::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valueOne.read(iprot);
          this->__isset.valueOne = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->op = (Op::type)ecast8;
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valueTwo.read(iprot);
          this->__isset.valueTwo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cond::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cond");
  xfer += oprot->writeFieldBegin("valueOne", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->valueOne.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.valueTwo) {
    xfer += oprot->writeFieldBegin("valueTwo", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->valueTwo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* KVIndexDef::ascii_fingerprint = "EE9507CF5E179F385D7466E797D385F7";
const uint8_t KVIndexDef::binary_fingerprint[16] = {0xEE,0x95,0x07,0xCF,0x5E,0x17,0x9F,0x38,0x5D,0x74,0x66,0xE7,0x97,0xD3,0x85,0xF7};

uint32_t KVIndexDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_name);
          this->__isset.m_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->m_columns.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            iprot->readListBegin(_etype12, _size9);
            this->m_columns.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += iprot->readI16(this->m_columns[_i13]);
            }
            iprot->readListEnd();
          }
          this->__isset.m_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KVIndexDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KVIndexDef");
  xfer += oprot->writeFieldBegin("m_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->m_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, this->m_columns.size());
    std::vector<int16_t> ::const_iterator _iter14;
    for (_iter14 = this->m_columns.begin(); _iter14 != this->m_columns.end(); ++_iter14)
    {
      xfer += oprot->writeI16((*_iter14));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* KVColumnDef::ascii_fingerprint = "2CB73F0A0DB08F76DB19C5B4173227AD";
const uint8_t KVColumnDef::binary_fingerprint[16] = {0x2C,0xB7,0x3F,0x0A,0x0D,0xB0,0x8F,0x76,0xDB,0x19,0xC5,0xB4,0x17,0x32,0x27,0xAD};

uint32_t KVColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->m_no);
          this->__isset.m_no = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_name);
          this->__isset.m_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->m_type = (DataType::type)ecast15;
          this->__isset.m_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->m_nullable);
          this->__isset.m_nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->m_nullBitmapOffset);
          this->__isset.m_nullBitmapOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KVColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KVColumnDef");
  xfer += oprot->writeFieldBegin("m_no", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->m_no);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->m_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->m_type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_nullable", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->m_nullable);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_nullBitmapOffset", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->m_nullBitmapOffset);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* KVTableDef::ascii_fingerprint = "529E90DD400DFEE6D2ED5C39EB259075";
const uint8_t KVTableDef::binary_fingerprint[16] = {0x52,0x9E,0x90,0xDD,0x40,0x0D,0xFE,0xE6,0xD2,0xED,0x5C,0x39,0xEB,0x25,0x90,0x75};

uint32_t KVTableDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_schemaName);
          this->__isset.m_schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_name);
          this->__isset.m_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->m_columns.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            iprot->readListBegin(_etype19, _size16);
            this->m_columns.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->m_columns[_i20].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.m_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->m_pkey.read(iprot);
          this->__isset.m_pkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->m_bmBytes);
          this->__isset.m_bmBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KVTableDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KVTableDef");
  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_schemaName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->m_schemaName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->m_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_columns", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, this->m_columns.size());
    std::vector<KVColumnDef> ::const_iterator _iter21;
    for (_iter21 = this->m_columns.begin(); _iter21 != this->m_columns.end(); ++_iter21)
    {
      xfer += (*_iter21).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_pkey", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->m_pkey.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m_bmBytes", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->m_bmBytes);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ServerException::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t ServerException::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t ServerException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->errcode = (ErrCode::type)ecast22;
          this->__isset.errcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServerException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServerException");
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("errcode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->errcode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace
#endif